```mermaid
graph TD A[Start] --> B{buddy_init()}; B --> C[Allocate memory pool (malloc)]; C --Success--> D{Check allocation success}; D --True--> E[Initialize free_list[MAX_ORDER + 1]]; E --> F[Create initial_block (struct buddy)]; F --> G[Set order = MAX_ORDER]; G --> H[Set free_list[MAX_ORDER] = initial_block]; H --> I[Initialize memory page map (mem_map) to 0]; I --> B2[buddy_alloc(order)]; B2 --> J{Check if order is valid (0 to MAX_ORDER)}; J --True--> K[Set current_order = order]; K --> L(While current_order <= MAX_ORDER and free_list[current_order] == NULL); L --True--> L; L --False--> M[Increment current_order]; M --> L; L --False--> N{If current_order > MAX_ORDER}; N --True--> O[Return NULL (no available block)]; N --False--> P[Extract a free block (struct buddy *block)]; P --> Q[Update free_list[current_order]]; Q --> R(While current_order > order); R --True--> S[Decrement current_order]; S --> T[Calculate split_block address]; T --> U[Set split_block->order to current_order]; U --> V[Link split_block to free_list[current_order]]; V --> R; R --False--> W[Update memory page usage map (mem_map)]; W --> X[Return block pointer]; X --> B2; B2 --> Y[buddy_free(addr, order)]; Y --> Z{Check parameters (addr, order validity)}; Z --True--> AA[Calculate page_index for addr]; AA --> BB[Update mem_map to mark pages as free]; BB --> CC[Set block's order to freed order]; CC --> DD(While order < MAX_ORDER); DD --True--> EE[Calculate buddy_index]; EE --> FF{Check if buddy block is free}; FF --True--> GG[Remove buddy block from free_list]; GG --> HH[Update page_index for combined block]; HH --> II[Increase order]; II --> DD; FF --False--> DD; DD --False--> JJ[Add the combined block back to free_list[order]]; JJ --> Y; Y --> KK[main()]; KK --> LL[Initialize buddy system]; LL --> MM[Allocate blocks (block1 and block2)]; MM --> NN[Free block1]; NN --> OO[Allocate block3]; OO --> PP[Free memory pool]; PP --> KK; KK --> Q2[End];

```